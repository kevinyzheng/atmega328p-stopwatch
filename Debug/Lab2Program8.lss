
Lab2Program8.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000324  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002b0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  00800100  00800100  00000324  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000324  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000354  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000394  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000009ca  00000000  00000000  0000041c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000006d1  00000000  00000000  00000de6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000846  00000000  00000000  000014b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000f4  00000000  00000000  00001d00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00010421  00000000  00000000  00001df4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000011b  00000000  00000000  00012215  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00012330  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00000194  00000000  00000000  000123a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	3d c0       	rjmp	.+122    	; 0x7c <__ctors_end>
   2:	00 00       	nop
   4:	4b c0       	rjmp	.+150    	; 0x9c <__bad_interrupt>
   6:	00 00       	nop
   8:	49 c0       	rjmp	.+146    	; 0x9c <__bad_interrupt>
   a:	00 00       	nop
   c:	47 c0       	rjmp	.+142    	; 0x9c <__bad_interrupt>
   e:	00 00       	nop
  10:	45 c0       	rjmp	.+138    	; 0x9c <__bad_interrupt>
  12:	00 00       	nop
  14:	43 c0       	rjmp	.+134    	; 0x9c <__bad_interrupt>
  16:	00 00       	nop
  18:	41 c0       	rjmp	.+130    	; 0x9c <__bad_interrupt>
  1a:	00 00       	nop
  1c:	3f c0       	rjmp	.+126    	; 0x9c <__bad_interrupt>
  1e:	00 00       	nop
  20:	3d c0       	rjmp	.+122    	; 0x9c <__bad_interrupt>
  22:	00 00       	nop
  24:	3b c0       	rjmp	.+118    	; 0x9c <__bad_interrupt>
  26:	00 00       	nop
  28:	39 c0       	rjmp	.+114    	; 0x9c <__bad_interrupt>
  2a:	00 00       	nop
  2c:	37 c0       	rjmp	.+110    	; 0x9c <__bad_interrupt>
  2e:	00 00       	nop
  30:	35 c0       	rjmp	.+106    	; 0x9c <__bad_interrupt>
  32:	00 00       	nop
  34:	33 c0       	rjmp	.+102    	; 0x9c <__bad_interrupt>
  36:	00 00       	nop
  38:	31 c0       	rjmp	.+98     	; 0x9c <__bad_interrupt>
  3a:	00 00       	nop
  3c:	2f c0       	rjmp	.+94     	; 0x9c <__bad_interrupt>
  3e:	00 00       	nop
  40:	2d c0       	rjmp	.+90     	; 0x9c <__bad_interrupt>
  42:	00 00       	nop
  44:	2b c0       	rjmp	.+86     	; 0x9c <__bad_interrupt>
  46:	00 00       	nop
  48:	29 c0       	rjmp	.+82     	; 0x9c <__bad_interrupt>
  4a:	00 00       	nop
  4c:	27 c0       	rjmp	.+78     	; 0x9c <__bad_interrupt>
  4e:	00 00       	nop
  50:	25 c0       	rjmp	.+74     	; 0x9c <__bad_interrupt>
  52:	00 00       	nop
  54:	23 c0       	rjmp	.+70     	; 0x9c <__bad_interrupt>
  56:	00 00       	nop
  58:	21 c0       	rjmp	.+66     	; 0x9c <__bad_interrupt>
  5a:	00 00       	nop
  5c:	1f c0       	rjmp	.+62     	; 0x9c <__bad_interrupt>
  5e:	00 00       	nop
  60:	1d c0       	rjmp	.+58     	; 0x9c <__bad_interrupt>
  62:	00 00       	nop
  64:	1b c0       	rjmp	.+54     	; 0x9c <__bad_interrupt>
  66:	00 00       	nop
  68:	a3 00       	.word	0x00a3	; ????
  6a:	8f 00       	.word	0x008f	; ????
  6c:	91 00       	.word	0x0091	; ????
  6e:	93 00       	.word	0x0093	; ????
  70:	95 00       	.word	0x0095	; ????
  72:	97 00       	.word	0x0097	; ????
  74:	99 00       	.word	0x0099	; ????
  76:	9b 00       	.word	0x009b	; ????
  78:	9d 00       	.word	0x009d	; ????
  7a:	9f 00       	.word	0x009f	; ????

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_clear_bss>:
  88:	21 e0       	ldi	r18, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	01 c0       	rjmp	.+2      	; 0x92 <.do_clear_bss_start>

00000090 <.do_clear_bss_loop>:
  90:	1d 92       	st	X+, r1

00000092 <.do_clear_bss_start>:
  92:	a5 30       	cpi	r26, 0x05	; 5
  94:	b2 07       	cpc	r27, r18
  96:	e1 f7       	brne	.-8      	; 0x90 <.do_clear_bss_loop>
  98:	c1 d0       	rcall	.+386    	; 0x21c <main>
  9a:	08 c1       	rjmp	.+528    	; 0x2ac <_exit>

0000009c <__bad_interrupt>:
  9c:	b1 cf       	rjmp	.-158    	; 0x0 <__vectors>

0000009e <timercounter1_init>:
}

void timercounter1_init(void) 
{
	// Timer/Counter1 Control Register
	TCCR1B |= (1<<CS11) ;		// Set prescaler to 8 using Clock Select bits
  9e:	e1 e8       	ldi	r30, 0x81	; 129
  a0:	f0 e0       	ldi	r31, 0x00	; 0
  a2:	80 81       	ld	r24, Z
  a4:	82 60       	ori	r24, 0x02	; 2
  a6:	80 83       	st	Z, r24
	// Output Compare Register - 
	/* Timer Frequency = 16 MHz/8/8 = 250000 Hz
	 * Timer Interval = 1/250000 = 0.004 ms
	 * 4ms/0.004ms = 1000 = (hex) 03E8
	 */
	OCR1A = OCR_4MS;		// TCNT1 will be compared to this value
  a8:	88 ee       	ldi	r24, 0xE8	; 232
  aa:	93 e0       	ldi	r25, 0x03	; 3
  ac:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
  b0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
	
	// Timer/Counter Register - counts timer "ticks"
	TCNT1 = 0;
  b4:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
  b8:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
  bc:	08 95       	ret

000000be <timercounter1_start_timer>:
}

void timercounter1_start_timer(void)
{
	// Wait until Timer Interrupt Flag Register (overflow) and Output Compare Interrupt Flag (ticks=OCR) are set
	while((TIFR1 & (1<<OCF1A)) == 0);
  be:	b1 9b       	sbis	0x16, 1	; 22
  c0:	fe cf       	rjmp	.-4      	; 0xbe <timercounter1_start_timer>
}
  c2:	08 95       	ret

000000c4 <timercounter1_reset_timer>:

void timercounter1_reset_timer(void)
{
	// Reset Timer/Counter Register
	TCNT1 = 0;
  c4:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
  c8:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	// Reset Timer Interrupt Flag Register
	TIFR1 |= (1<<OCF1A);
  cc:	b1 9a       	sbi	0x16, 1	; 22
  ce:	08 95       	ret

000000d0 <time_values_init>:
}

void time_values_init(void)
{
	minutes = 0;
  d0:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <minutes>
	ten_seconds = 0;
  d4:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <ten_seconds>
	seconds = 0;
  d8:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <seconds>
	tenth_seconds = 0;
  dc:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <tenth_seconds>
	twenty_milliseconds = 0;
  e0:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
  e4:	08 95       	ret

000000e6 <io_init>:
}

void io_init(void)
{
	// Inputs
	DDRD &= ~(1 << STARTSTOP);					// Set as input
  e6:	50 98       	cbi	0x0a, 0	; 10
	DDRD &= ~(1 << RESET);						// Set as input
  e8:	53 98       	cbi	0x0a, 3	; 10
	PORTD |= (1 << STARTSTOP)|(1 << RESET);		// Enable internal pull-up resistors
  ea:	8b b1       	in	r24, 0x0b	; 11
  ec:	89 60       	ori	r24, 0x09	; 9
  ee:	8b b9       	out	0x0b, r24	; 11
	
	// Outputs
	// Data Direction Register C
	DDRC |= (1<<DIGIT4)|(1<<DIGIT3)|(1<<DIGIT2)|(1<<DIGIT1);		// Set PC 1-4 as outputs
  f0:	87 b1       	in	r24, 0x07	; 7
  f2:	8e 61       	ori	r24, 0x1E	; 30
  f4:	87 b9       	out	0x07, r24	; 7
  f6:	08 95       	ret

000000f8 <check_startstop_state>:
}

unsigned char check_startstop_state(void)
{
	if (!(PIND & (1<<STARTSTOP))) return 1;		// return 1 if PIND value is 0 or STARTSTOP is pressed
  f8:	89 b1       	in	r24, 0x09	; 9
  fa:	80 95       	com	r24
	return 0;
}
  fc:	81 70       	andi	r24, 0x01	; 1
  fe:	08 95       	ret

00000100 <check_reset_state>:
	while(check_startstop_state()) display_time_values();
}

unsigned char check_reset_state(void)
{
	if (!(PIND & (1<<RESET))) return 1;	// return 1 if PIND value is 0 or RESET is pressed
 100:	89 b1       	in	r24, 0x09	; 9
 102:	83 fb       	bst	r24, 3
 104:	88 27       	eor	r24, r24
 106:	80 f9       	bld	r24, 0
	return 0;
}
 108:	91 e0       	ldi	r25, 0x01	; 1
 10a:	89 27       	eor	r24, r25
 10c:	08 95       	ret

0000010e <digit_lookup>:

uint8_t digit_lookup(uint8_t number)
{
	switch(number)
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	8a 30       	cpi	r24, 0x0A	; 10
 112:	91 05       	cpc	r25, r1
 114:	b0 f4       	brcc	.+44     	; 0x142 <digit_lookup+0x34>
 116:	fc 01       	movw	r30, r24
 118:	ec 5c       	subi	r30, 0xCC	; 204
 11a:	ff 4f       	sbci	r31, 0xFF	; 255
 11c:	c1 c0       	rjmp	.+386    	; 0x2a0 <__tablejump2__>
	{
		case 0:
			return 0b00111111;
			break;
		case 1:
			return 0b00000110;
 11e:	86 e0       	ldi	r24, 0x06	; 6
 120:	08 95       	ret
			break;
		case 2:
			return 0b01011011;
 122:	8b e5       	ldi	r24, 0x5B	; 91
 124:	08 95       	ret
			break;
		case 3:
			return 0b01001111;
 126:	8f e4       	ldi	r24, 0x4F	; 79
 128:	08 95       	ret
			break;
		case 4:
			return 0b01100110;
 12a:	86 e6       	ldi	r24, 0x66	; 102
 12c:	08 95       	ret
			break;
		case 5:
			return 0b01101101;
 12e:	8d e6       	ldi	r24, 0x6D	; 109
 130:	08 95       	ret
			break;
		case 6:
			return 0b01111101;
 132:	8d e7       	ldi	r24, 0x7D	; 125
 134:	08 95       	ret
			break;
		case 7:
			return 0b00000111;
 136:	87 e0       	ldi	r24, 0x07	; 7
 138:	08 95       	ret
			break;
		case 8:
			return 0b01111111;
 13a:	8f e7       	ldi	r24, 0x7F	; 127
 13c:	08 95       	ret
			break;
		case 9:
			return 0b01100111;
 13e:	87 e6       	ldi	r24, 0x67	; 103
 140:	08 95       	ret
			break;	
	}
	return 0;
 142:	80 e0       	ldi	r24, 0x00	; 0
 144:	08 95       	ret
uint8_t digit_lookup(uint8_t number)
{
	switch(number)
	{
		case 0:
			return 0b00111111;
 146:	8f e3       	ldi	r24, 0x3F	; 63
		case 9:
			return 0b01100111;
			break;	
	}
	return 0;
}
 148:	08 95       	ret

0000014a <distribute_tenth_seconds>:

void distribute_tenth_seconds(void)
{
	if (tenth_seconds >= 10)
 14a:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <tenth_seconds>
 14e:	8a 30       	cpi	r24, 0x0A	; 10
 150:	28 f1       	brcs	.+74     	; 0x19c <distribute_tenth_seconds+0x52>
	{
		tenth_seconds -= 10;
 152:	8a 50       	subi	r24, 0x0A	; 10
 154:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <tenth_seconds>
		seconds++;
 158:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <seconds>
 15c:	91 e0       	ldi	r25, 0x01	; 1
 15e:	98 0f       	add	r25, r24
		if (seconds >= 10) 
 160:	9a 30       	cpi	r25, 0x0A	; 10
 162:	18 f4       	brcc	.+6      	; 0x16a <distribute_tenth_seconds+0x20>
void distribute_tenth_seconds(void)
{
	if (tenth_seconds >= 10)
	{
		tenth_seconds -= 10;
		seconds++;
 164:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <seconds>
 168:	08 95       	ret
		if (seconds >= 10) 
		{
			seconds -= 10;
 16a:	89 50       	subi	r24, 0x09	; 9
 16c:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <seconds>
			ten_seconds++;
 170:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ten_seconds>
 174:	91 e0       	ldi	r25, 0x01	; 1
 176:	98 0f       	add	r25, r24
			if (ten_seconds >= 6) 
 178:	96 30       	cpi	r25, 0x06	; 6
 17a:	18 f4       	brcc	.+6      	; 0x182 <distribute_tenth_seconds+0x38>
		tenth_seconds -= 10;
		seconds++;
		if (seconds >= 10) 
		{
			seconds -= 10;
			ten_seconds++;
 17c:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <ten_seconds>
 180:	08 95       	ret
			if (ten_seconds >= 6) 
			{
				ten_seconds -= 6;
 182:	85 50       	subi	r24, 0x05	; 5
 184:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <ten_seconds>
				minutes++;
 188:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <minutes>
 18c:	8f 5f       	subi	r24, 0xFF	; 255
				if (minutes >= 10) minutes = 0;
 18e:	8a 30       	cpi	r24, 0x0A	; 10
 190:	18 f4       	brcc	.+6      	; 0x198 <distribute_tenth_seconds+0x4e>
			seconds -= 10;
			ten_seconds++;
			if (ten_seconds >= 6) 
			{
				ten_seconds -= 6;
				minutes++;
 192:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <minutes>
 196:	08 95       	ret
				if (minutes >= 10) minutes = 0;
 198:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <minutes>
 19c:	08 95       	ret

0000019e <spi_main_init>:
	}
}

void spi_main_init(void)
{
	DDRB |= (1<<MOSI)|(1<<SCK)|(1<<SS);	// Set MOSI, SCK and SS as outputs
 19e:	84 b1       	in	r24, 0x04	; 4
 1a0:	8c 62       	ori	r24, 0x2C	; 44
 1a2:	84 b9       	out	0x04, r24	; 4
	
	// SPI Control Register
	SPCR = (1<<SPE)|(1<<MSTR);	// SPI Enable, set as main
 1a4:	80 e5       	ldi	r24, 0x50	; 80
 1a6:	8c bd       	out	0x2c, r24	; 44
	
	// SPI Status Register
	SPSR = (1<<SPI2X);			// Divide frequency by 2 to get 1MHz (16MHz/8/2 = 1MHz)
 1a8:	81 e0       	ldi	r24, 0x01	; 1
 1aa:	8d bd       	out	0x2d, r24	; 45
 1ac:	08 95       	ret

000001ae <spi_transmit>:
}

void spi_transmit (uint8_t data)
{
	SPDR = data;					// store output in SPI Data Register, where transfer takes place
 1ae:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));     // wait for SPI Status Register and SPI Interrupt Flag to signal end of transmission
 1b0:	0d b4       	in	r0, 0x2d	; 45
 1b2:	07 fe       	sbrs	r0, 7
 1b4:	fd cf       	rjmp	.-6      	; 0x1b0 <spi_transmit+0x2>
	
	// pulse SS
	PORTB |= (1 << SS);				// force SS high
 1b6:	2a 9a       	sbi	0x05, 2	; 5
	PORTB &= ~(1 << SS);			// force SS low
 1b8:	2a 98       	cbi	0x05, 2	; 5
 1ba:	08 95       	ret

000001bc <display_time_values>:
	twenty_milliseconds = 0;
}

void display_time_values(void){
	// tenth seconds
	PORTC |= (1 << DIGIT1);											// force digit 1 high (to be used)
 1bc:	44 9a       	sbi	0x08, 4	; 8
	PORTC &= ~(1 << DIGIT2) & ~(1 << DIGIT3) & ~(1 << DIGIT4);		// force digits 2,3,4 low (not used)
 1be:	88 b1       	in	r24, 0x08	; 8
 1c0:	81 7f       	andi	r24, 0xF1	; 241
 1c2:	88 b9       	out	0x08, r24	; 8
	spi_transmit(digit_lookup(tenth_seconds));						// determine segments to light up, transmit over SPI
 1c4:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <tenth_seconds>
 1c8:	a2 df       	rcall	.-188    	; 0x10e <digit_lookup>
 1ca:	f1 df       	rcall	.-30     	; 0x1ae <spi_transmit>
	timercounter1_start_timer();									// 4ms delay
 1cc:	78 df       	rcall	.-272    	; 0xbe <timercounter1_start_timer>
 1ce:	7a df       	rcall	.-268    	; 0xc4 <timercounter1_reset_timer>
	timercounter1_reset_timer();
 1d0:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <seconds>
	
	
	// one seconds
	spi_transmit(digit_lookup(seconds)+0b10000000);					// determine segments to light up, transmit over SPI
 1d4:	9c df       	rcall	.-200    	; 0x10e <digit_lookup>
 1d6:	80 58       	subi	r24, 0x80	; 128
 1d8:	ea df       	rcall	.-44     	; 0x1ae <spi_transmit>
 1da:	43 9a       	sbi	0x08, 3	; 8
	PORTC |= (1 << DIGIT2);											// force digit 2 high (to be used)
 1dc:	88 b1       	in	r24, 0x08	; 8
	PORTC &= ~(1 << DIGIT1) & ~(1 << DIGIT3) & ~(1 << DIGIT4);		// force digits 1,3,4 low (not used)
 1de:	89 7e       	andi	r24, 0xE9	; 233
 1e0:	88 b9       	out	0x08, r24	; 8
	timercounter1_start_timer();									// 4ms delay
 1e2:	6d df       	rcall	.-294    	; 0xbe <timercounter1_start_timer>
 1e4:	6f df       	rcall	.-290    	; 0xc4 <timercounter1_reset_timer>
	timercounter1_reset_timer();
 1e6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ten_seconds>
	
	
	// ten seconds
	spi_transmit(digit_lookup(ten_seconds));						// determine segments to light up, transmit over SPI
 1ea:	91 df       	rcall	.-222    	; 0x10e <digit_lookup>
 1ec:	e0 df       	rcall	.-64     	; 0x1ae <spi_transmit>
 1ee:	42 9a       	sbi	0x08, 2	; 8
 1f0:	88 b1       	in	r24, 0x08	; 8
	PORTC |= (1 << DIGIT3);											// force digit 3 high (to be used)
 1f2:	85 7e       	andi	r24, 0xE5	; 229
	PORTC &= ~(1 << DIGIT2) & ~(1 << DIGIT1) & ~(1 << DIGIT4);		// force digits 2,1,4 low (not used)
 1f4:	88 b9       	out	0x08, r24	; 8
 1f6:	63 df       	rcall	.-314    	; 0xbe <timercounter1_start_timer>
 1f8:	65 df       	rcall	.-310    	; 0xc4 <timercounter1_reset_timer>
	timercounter1_start_timer();									// 4ms delay
 1fa:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <minutes>
	timercounter1_reset_timer();
 1fe:	87 df       	rcall	.-242    	; 0x10e <digit_lookup>
	
	
	// minutes
	spi_transmit(digit_lookup(minutes));							// determine segments to light up, transmit over SPI
 200:	d6 df       	rcall	.-84     	; 0x1ae <spi_transmit>
 202:	41 9a       	sbi	0x08, 1	; 8
 204:	88 b1       	in	r24, 0x08	; 8
 206:	83 7e       	andi	r24, 0xE3	; 227
 208:	88 b9       	out	0x08, r24	; 8
 20a:	59 df       	rcall	.-334    	; 0xbe <timercounter1_start_timer>
	PORTC |= (1 << DIGIT4);											// force digit 4 high (to be used)
 20c:	5b cf       	rjmp	.-330    	; 0xc4 <timercounter1_reset_timer>
	PORTC &= ~(1 << DIGIT2) & ~(1 << DIGIT3) & ~(1 << DIGIT1);		// force digits 2,3,1 low (not used)
 20e:	08 95       	ret

00000210 <wait_startstop_state>:
 210:	01 c0       	rjmp	.+2      	; 0x214 <wait_startstop_state+0x4>
 212:	d4 df       	rcall	.-88     	; 0x1bc <display_time_values>
	timercounter1_start_timer();									// 4ms delay
 214:	71 df       	rcall	.-286    	; 0xf8 <check_startstop_state>
 216:	81 11       	cpse	r24, r1
	timercounter1_reset_timer();
 218:	fc cf       	rjmp	.-8      	; 0x212 <wait_startstop_state+0x2>
 21a:	08 95       	ret

0000021c <main>:
 21c:	40 df       	rcall	.-384    	; 0x9e <timercounter1_init>
void spi_transmit(uint8_t data);

int main(void)
{
	timercounter1_init();
	io_init();
 21e:	63 df       	rcall	.-314    	; 0xe6 <io_init>
	spi_main_init();
 220:	be df       	rcall	.-132    	; 0x19e <spi_main_init>
	time_values_init();
 222:	56 df       	rcall	.-340    	; 0xd0 <time_values_init>
 224:	69 df       	rcall	.-302    	; 0xf8 <check_startstop_state>
	
	while(1)
	{			
		if(check_startstop_state())			// start/continue timer
 226:	88 23       	and	r24, r24
 228:	09 f4       	brne	.+2      	; 0x22c <main+0x10>
 22a:	32 c0       	rjmp	.+100    	; 0x290 <main+0x74>
		{
			wait_startstop_state();			// wait until button is released
 22c:	f1 df       	rcall	.-30     	; 0x210 <wait_startstop_state>
			while(!check_startstop_state())
			{
				if(check_startstop_state()){			// check if button is pressed
 22e:	2d c0       	rjmp	.+90     	; 0x28a <main+0x6e>
 230:	63 df       	rcall	.-314    	; 0xf8 <check_startstop_state>
					wait_startstop_state(); break; }	// wait until button is released and break
 232:	88 23       	and	r24, r24
 234:	11 f0       	breq	.+4      	; 0x23a <main+0x1e>
				
				display_time_values();			// 16ms
 236:	ec df       	rcall	.-40     	; 0x210 <wait_startstop_state>
 238:	2b c0       	rjmp	.+86     	; 0x290 <main+0x74>
				timercounter1_start_timer();	// 4ms
 23a:	c0 df       	rcall	.-128    	; 0x1bc <display_time_values>
 23c:	40 df       	rcall	.-384    	; 0xbe <timercounter1_start_timer>
				timercounter1_reset_timer();
 23e:	42 df       	rcall	.-380    	; 0xc4 <timercounter1_reset_timer>
				
				if(check_startstop_state()){
 240:	5b df       	rcall	.-330    	; 0xf8 <check_startstop_state>
 242:	88 23       	and	r24, r24
 244:	11 f0       	breq	.+4      	; 0x24a <main+0x2e>
					wait_startstop_state(); break; }
 246:	e4 df       	rcall	.-56     	; 0x210 <wait_startstop_state>
 248:	23 c0       	rjmp	.+70     	; 0x290 <main+0x74>
 24a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
						
				twenty_milliseconds++;
 24e:	8f 5f       	subi	r24, 0xFF	; 255
 250:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 254:	51 df       	rcall	.-350    	; 0xf8 <check_startstop_state>
				
				if(check_startstop_state()){
 256:	88 23       	and	r24, r24
 258:	11 f0       	breq	.+4      	; 0x25e <main+0x42>
 25a:	da df       	rcall	.-76     	; 0x210 <wait_startstop_state>
					wait_startstop_state(); break; }
 25c:	19 c0       	rjmp	.+50     	; 0x290 <main+0x74>
 25e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
								
				if (twenty_milliseconds>=5)		// true if time elapsed is 100ms
 262:	85 30       	cpi	r24, 0x05	; 5
				{
					twenty_milliseconds = 0;
 264:	68 f0       	brcs	.+26     	; 0x280 <main+0x64>
					tenth_seconds++;			// increment tenth seconds (100ms)
 266:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
 26a:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <tenth_seconds>
					distribute_tenth_seconds();
 26e:	8f 5f       	subi	r24, 0xFF	; 255
					
					if(check_startstop_state()){
 270:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <tenth_seconds>
 274:	6a df       	rcall	.-300    	; 0x14a <distribute_tenth_seconds>
						wait_startstop_state(); break; }
 276:	40 df       	rcall	.-384    	; 0xf8 <check_startstop_state>
 278:	88 23       	and	r24, r24
 27a:	11 f0       	breq	.+4      	; 0x280 <main+0x64>
				}
			if(check_startstop_state()){
 27c:	c9 df       	rcall	.-110    	; 0x210 <wait_startstop_state>
 27e:	08 c0       	rjmp	.+16     	; 0x290 <main+0x74>
 280:	3b df       	rcall	.-394    	; 0xf8 <check_startstop_state>
 282:	88 23       	and	r24, r24
				wait_startstop_state(); break; }	
 284:	11 f0       	breq	.+4      	; 0x28a <main+0x6e>
 286:	c4 df       	rcall	.-120    	; 0x210 <wait_startstop_state>
 288:	03 c0       	rjmp	.+6      	; 0x290 <main+0x74>
	while(1)
	{			
		if(check_startstop_state())			// start/continue timer
		{
			wait_startstop_state();			// wait until button is released
			while(!check_startstop_state())
 28a:	36 df       	rcall	.-404    	; 0xf8 <check_startstop_state>
 28c:	88 23       	and	r24, r24
 28e:	81 f2       	breq	.-96     	; 0x230 <main+0x14>
 290:	95 df       	rcall	.-214    	; 0x1bc <display_time_values>
				}
			if(check_startstop_state()){
				wait_startstop_state(); break; }	
			}
		}
		display_time_values();
 292:	36 df       	rcall	.-404    	; 0x100 <check_reset_state>
 294:	88 23       	and	r24, r24
		if(check_reset_state())			// reset timer
 296:	09 f4       	brne	.+2      	; 0x29a <main+0x7e>
 298:	c5 cf       	rjmp	.-118    	; 0x224 <main+0x8>
 29a:	1a df       	rcall	.-460    	; 0xd0 <time_values_init>
 29c:	8f df       	rcall	.-226    	; 0x1bc <display_time_values>
 29e:	c2 cf       	rjmp	.-124    	; 0x224 <main+0x8>

000002a0 <__tablejump2__>:
		{
			time_values_init();
 2a0:	ee 0f       	add	r30, r30
 2a2:	ff 1f       	adc	r31, r31
			display_time_values();
 2a4:	05 90       	lpm	r0, Z+
 2a6:	f4 91       	lpm	r31, Z
			continue;
 2a8:	e0 2d       	mov	r30, r0
 2aa:	09 94       	ijmp

000002ac <_exit>:
 2ac:	f8 94       	cli

000002ae <__stop_program>:
 2ae:	ff cf       	rjmp	.-2      	; 0x2ae <__stop_program>
